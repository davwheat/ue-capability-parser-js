const ArrayRegexPattern = /\s*\[(\d*)\]\s*/;

export default class NSGLogParser {
  /**
   * Converts a textual signalling log from Network Signal Guru into a Javascript object.
   *
   * This does **not** handle DLF-style logs or .log.gz files generated by NSG, only copied
   * signalling data from the signalling page.
   *
   * @example
   * ```ts
   * `
   * ul-dcch
   *  message -> c1 -> ueCapabilityInformation
   *   rrc-TransactionIdentifier : 2
   * `
   * // would become
   * {
   *   'ul-dcch': {
   *     message: {
   *       c1: {
   *         ueCapabilityInformation: {
   *           'rrc-TransactionIdentifier': '2',
   *         },
   *       },
   *    },
   *   },
   * }
   * ```
   */
  logToJsObject(text: string): Record<string, any> {
    const data: Record<string, any> = {};

    const lines = text.split('\n').filter((l) => l.trim().length > 0);

    let previousIndent = -1;

    function peekAhead(i: number, offset: number = 1): string | undefined {
      return lines?.[i + offset];
    }

    function peekBehind(i: number, offset: number = 1): string | undefined {
      return lines?.[i - offset];
    }

    const currentPath: (string | number)[] = [];
    let extraBacktracks: Record<number, number> = {};

    lines.forEach((line, i) => {
      const newIndent = line.length - line.trimStart().length;

      if (newIndent < previousIndent) {
        let backtrackCount = previousIndent - newIndent;

        Array.from({ length: backtrackCount }, (_, i) => newIndent + i).forEach((passingIndex) => {
          if (extraBacktracks[passingIndex]) {
            backtrackCount += extraBacktracks[passingIndex];
            extraBacktracks[passingIndex] = 0;
          }
        });

        // pop off keys
        for (let i = 0; i < backtrackCount; i++) {
          currentPath.pop();
        }
      }

      if (line.match(/.* : .*/)) {
        // add new key/value to current obj

        let currentData: Record<string, any> | any[] = data;
        currentPath.forEach((k) => (currentData = (currentData as any)[k]));

        const [key, value] = line.split(' : ').map((k) => k.trim());

        currentData[key] = value;
      } else if (line.match(ArrayRegexPattern)) {
        // do nothing -- don't need to handle array indexes

        const [, index] = line.match(ArrayRegexPattern)!;

        let currentData: Record<string, any> | any[] = data;
        currentPath.slice(0, -1).forEach((k) => (currentData = (currentData as any)[k]));

        currentData[currentPath[currentPath.length - 1]] ||= [];

        const isArr = peekAhead(i)?.match(ArrayRegexPattern) ? true : false;
        currentData[currentPath[currentPath.length - 1]][parseInt(index)] ||= isArr ? [] : {};

        currentPath.push(parseInt(index));
      } else {
        // new key

        let currentData: Record<string, any> = data;
        currentPath.forEach((k) => (currentData = currentData[k]));

        let keys: string[] = [line.trim()];
        let isKeyArray: boolean = false;

        if (line.includes(' -> ')) {
          // need to handle deep nesting
          extraBacktracks[newIndent] ||= 0;

          keys = line.split('->').map((k) => {
            extraBacktracks[newIndent]++;
            return k.trim();
          });

          extraBacktracks[newIndent]--;
        }

        let nextLine = peekAhead(i);
        if (
          nextLine && // next line is found
          nextLine.length - nextLine.trimStart().length > newIndent && // is more indented than this one
          nextLine.match(ArrayRegexPattern) // and looks like an array (`[x]`)
        ) {
          // next line is an array index, so this obj we're creating should be an
          // array rather than JS obj
          isKeyArray = true;
        }

        keys.forEach((k, i, arr) => {
          currentData[k] = isKeyArray && i === arr.length - 1 ? [] : {};
          currentData = currentData[k];
          currentPath.push(k);
        });
      }

      // clean-up
      previousIndent = newIndent;
    });

    return data;
  }
}
